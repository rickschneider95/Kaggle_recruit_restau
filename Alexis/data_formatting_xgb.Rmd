---
title: "format_data_xgb"
author: "Alexis Laks"
date: "29/11/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(onehot)
library(data.table)
library(mltools)
library(dplyr)
library(stringr)
library(lubridate)
library(caret)
```

This file will be dedicated to formatting the complete_data.csv file to feed to the xgb model.


# loading space according to your preferences: (:o)<--<

```{r}
dataset <- read.csv("data/complete_data.csv")
colSums(is.na(dataset))
```

```{r}
data_air <- dataset %>% filter(str_detect(id, "^air"))
sum(is.na(data_air))
```

```{r}
data_hpg <- dataset %>% filter(str_detect(id, "^hpg"))
```

A SUPPRIMER @ALEXIS????
# Change dataframe 
```{r}
data <- data %>%
  mutate(day_visit = day(dmy(visit_date)), #extract visit day from date
         day_reserve = day(dmy(reserve_date)),  #extract reserve day from date
         month_visit = month(dmy(visit_date)),   #extract visit month from date
         month_reserve = month(dmy(reserve_date)), #extract reserve month from date
         year_visit = year(dmy(visit_date)), #extract visit year from date
         year_reserve = year(dmy(visit_date)), #extract reserve year from date
         latency_days=ifelse(is.na(reserve_date),0,as.numeric(as.Date(visit_date)-as.Date(reserve_date))), #days between reservation vs visit. if no reservation then will be 0
         latency_people=ifelse(is.na(reserve_visitors),0,visitors-reserve_visitors),
         visit_time=as.factor(str_sub(as.character(visit_time), start = 0, end = 3)),
        reserve_time = as.factor(str_sub(as.character(reserve_time), start = 0, end = 3)),
        reserve_date = as.factor(str_sub(as.character(reserve_date), start = 6, end = 7)),
        visit_date=as.factor(str_sub(as.character(visit_date), start = 6, end = 7))) #difference in the number of people from the party between reservation vs visit. if no reservation then will be 0


one_h$reserve_date <- as.factor(str_sub(as.character(one_h$reserve_date), start = 0, end = 4))
visit_date <- as.factor(str_sub(as.character(one_h$visit_date), start = 0, end = 4))
area_name = as.factor(substr(area_name, 0, 8))
ne_h$day_of_the_week_visit <- as.factor(one_h$day_of_the_week_visit)
one_h$day_of_the_week_reserve <- as.factor(one_h$day_of_the_week_visit)

```

# data change
```{r}
datal <- dataset %>%
  mutate(day_visit = day(dmy(visit_date)), #extract visit day from date
         day_reserve = day(dmy(reserve_date)),  #extract reserve day from date
         month_visit = month(dmy(visit_date)),   #extract visit month from date
         month_reserve = month(dmy(reserve_date)), #extract reserve month from date
         year_visit = year(dmy(visit_date)), #extract visit year from date
         year_reserve = year(dmy(visit_date)), #extract reserve year from date
         latency_days=ifelse(is.na(reserve_date),0,as.numeric(as.Date(visit_date)-as.Date(reserve_date))), #days between reservation vs visit. if no reservation then will be 0
         latency_people=ifelse(is.na(reserve_visitors),0,visitors-reserve_visitors)) #difference in the number of people from the party between reservation vs visit. if no reservation then will be 0
```
FIN DE SUPPRESSION POTENTIELLE????



## ONE HOT ENCODING ON FIRST BASE VARS

This is the one hot encoding section (under form of functions) for the variables we start with in the complete dataset. Splitting them into functions was a conscious choice that gives us more flexibility as to what we want to one-hot encode, if we want to change the code at a later time. 

# One hot encoding for VISIT time:

```{r}
vtime_transf <- function(data){
  one_h <- data
  one_h$visit_time <- as.factor(str_sub(as.character(one_h$visit_time), start = 0, end = 3)) #extract the hour in the time: e.g: takes 19 out of 19:00:00 
  one_h <- one_h %>% select(visit_time)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for RESERVE time:

```{r}
rtime_transf <- function(data){
  one_h <- data
  one_h$reserve_time <- as.factor(str_sub(as.character(one_h$reserve_time), start = 0, end = 3)) #extract the hour in the time: e.g: takes 19 out of 19:00:00 
  one_h <- one_h %>% select(reserve_time)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for reserve MONTH:

```{r}
rmonth_transf <- function(data){
  one_h <- data
  one_h$reserve_date <- as.factor(str_sub(as.character(one_h$reserve_date), start = 6, end = 7)) #extract the month number in the date (eg December is 12)
  one_h <- one_h %>% select(reserve_date)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for visit MONTH:

```{r}
vmonth_transf <- function(data){
  one_h <- data
  one_h$visit_date <- as.factor(str_sub(as.character(one_h$visit_date), start = 6, end = 7)) #extract the month number in the date (eg December is 12)
  one_h <- one_h %>% select(visit_date)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for reserve YEAR:

```{r}
ryear_transf <- function(data){
  one_h <- data
  one_h$reserve_date <- as.factor(str_sub(as.character(one_h$reserve_date), start = 0, end = 4))
  one_h <- one_h %>% select(reserve_date)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for visit YEAR:

```{r}
vyear_transf <- function(data){
  one_h <- data
  one_h$visit_date <- as.factor(str_sub(as.character(one_h$visit_date), start = 0, end = 4))
  one_h <- one_h %>% select(visit_date)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding AREA:

This is the one hot encoder function for the original area name variable. I don't recommend using at as it create way too many entries, instead in the FEATURE ENGINEERING part of this rmd that you'll find below, there is an adapted function which keeps all the info while generating way less entries. Still, here's a glimpse at the transformation on the original variable:

```{r}
basic_area_transf <- function(data){
  one_h <- data
  one_h <- data %>%
    select(area_name) %>% 
    mutate(area_name = as.character(area_name)) %>% 
    mutate(area_name = as.factor(case_when(area_name == "Osaka Prefecture Osaka None" ~ "Ōsaka-fu Prefecture Osaka None",
                                 TRUE ~ area_name))) ## This is just an error in the data set 
  one_h <- one_hot(as.data.table(one_h))
  try <- data %>% cbind(one_h)
}
```

# One hot encoding for DAY OF THE WEEK RESERVE:

```{r}
rdayweek_transf <- function(data){
  one_h <- data
  one_h <- one_h %>% select(day_of_the_week_visit)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for DAY OF THE WEEK VISIT:

```{r}
vdayweek_transf <- function(data){
  one_h <- data
  one_h <- one_h %>% select(day_of_the_week_visit)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for LONGITUDE:
DONT RUN

```{r}
lat_transf <- function(data){
  one_h <- data
  one_h$latitude <- as.factor(one_h$latitude)
  one_h <- one_h %>% select(latitude)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding for LATITUDE:
DONT RUN

```{r}
lon_transf <- function(data){
  one_h <- data
  one_h$longitude <- as.factor(str_sub(as.character(one_h$longitude), start = 0, end = 4))
  one_h <- one_h %>% select(longitude)
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

## FEATURE ENGINEERING:

**Creating new variables and one-hot encoding them for xgb program**

# One hot encoding for LUNCH/DINNER:

```{r}
dn_transf <- function(data){
  one_h <- data %>% 
    select(visit_time) %>% 
    mutate(visit_time = as.integer(str_sub(as.character(visit_time),
                                  start = 0,
                                  end = 3)
                          )) %>% 
    mutate(visit_time = as.factor(case_when(visit_time >= 4 & visit_time <= 16 ~ "day",
                                                   TRUE ~ "night")))
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```

# One hot encoding (Better version) AREA:

There are many different levels for area names, although they all appartain to one particular city. I'll regroup observations appartaining to the same big city (Tokyo, Kyoto, Osaka, etc...) and onehot encode on this smaller amount of levels.

```{r}
area_transf <- function(data){
  one_h <- data
  one_h <- one_h %>%
    select(area_name) %>% 
    mutate(area_name = as.character(area_name)) %>% 
    mutate(area_name = case_when(area_name == "Osaka Prefecture Osaka None" ~ "Ōsaka-fu Prefecture Osaka None",
                   TRUE ~ area_name)) %>% # error in the data
    mutate(area_name = as.factor(substr(area_name, 0, 8)))
  one_h <- one_hot(as.data.table(one_h))
  try <- data %>% cbind(one_h)
}
```

Difference is huge, we get 15 levels with the above function vs 130 from the basic one. TAKE THIS ONE PLEASE SENPAI

# one hot encoding for LATENCY

```{r}
latency_transf <- function(data){
  one_h <- data
  one_h <- one_h %>%
    mutate(latency_days = as.integer(ifelse(is.na(reserve_date), 0, as.numeric(as.Date(visit_date) - as.Date(reserve_date))))) %>% 
    select(latency_days) %>% 
    mutate(latency_days = as.factor(case_when(latency_days >= 0 & latency_days <= 7 ~ "casual",
                                              latency_days > 7 & latency_days <= 30 ~ "fancy",
                                                   TRUE ~ "very fancy")))
  one_h <- one_hot(as.data.table(one_h))
  data <- data %>% cbind(one_h)
}
```


## TRY CHUNK ( TRY MY CHUNK (:^<) )

this chunk is for you to test out the different one hot encoding functions. have fun.

```{r}
try <- data_air
try <- rtime_transf(try)
try <- vtime_transf(try)
try <- rmonth_transf(try)
try <- vmonth_transf(try)
try <- ryear_transf(try)
try <- vyear_transf(try)
try <- area_transf(try)
try <- dn_transf(try)
try <- vdayweek_transf(try)
try <- rdayweek_transf(try)

try

## Obsolete bin :

# try <- basic_area_transf(try)

## To debug bin:

# try <- lat_transf(try)
# try <- lon_transf(try) Doesn't work, i'll look more into it later on but this fct is kinda bs tbh
```

**NOTES**

- Need to one hot code genres!

- replace reservation times by average diff in res/visit for each ID !!!

-group_by id,date and summarise -> get the total number of visits per day. (per noon,night?) 
      => solution: seperate data set in visits for noon/ visits for ngiht and run xgb on each separately

-We're taking out lon/lat for now, we already have the area name for location info (there still is a function to one hot code it though just in case) CAREFUL it creates like 130 columns LMA0

- We have NA's for day of the week reserve and day of the week visit:

```{r}
sum(is.na(data_air$day_of_the_week_reserve))
sum(is.na(data$day_of_the_week_visit))
```

# ONE HOT XGB CSV CREATION CHUNK

```{r}
try <- try[,-c(3:5)]
try <- try[,-c(4:8)]
final_try <- try[,-c(5)]

write.csv(final_try, "data/data_1h_xgb.csv", row.names = FALSE)

trytry <- read.csv("data/data_1h_xgb.csv")
trytry

colSums(is.na.data.frame(trytry))
nrow(trytry)
```
